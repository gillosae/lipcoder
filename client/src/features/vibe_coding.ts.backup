import * as vscode from 'vscode';
import { speakTokenList, TokenChunk } from '../audio';
import { log } from '../utils';
import * as Diff from 'diff';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

interface CodeChange {
    line: number;
    original: string;
    modified: string;
    type: 'added' | 'removed' | 'modified';
}

interface VibeCodingResult {
    changes: CodeChange[];
    summary: string;
    totalAdded: number;
    totalRemoved: number;
    modifiedText: string;
}

interface ContextInfo {
    selectedCode: string;
    focusedFunction: string | null;
    cursorPosition: vscode.Position;
    contextLines: string[];
    isLargeFile: boolean;
}

export async function activateVibeCoding() {
    const editor = vscode.window.activeTextEditor;
    if (!editor) {
        await speakTokenList([{ tokens: ['No active editor'], category: undefined }]);
        return;
    }

    // Get intelligent context
    const context = await getIntelligentContext(editor);
    
    // Show input box for natural language instruction
    const instruction = await vscode.window.showInputBox({
        placeHolder: 'Describe what you want to change in the code...',
        prompt: `Vibe Coding: Describe your desired code changes in natural language\n\nContext: ${context.focusedFunction ? 'Function under cursor' : context.selectedCode ? 'Selected code' : 'Entire file'}${context.isLargeFile ? ' (large file)' : ''}`,
        value: '',
        ignoreFocusOut: true
    });

    if (!instruction) {
        await speakTokenList([{ tokens: ['No instruction provided'], category: undefined }]);
        return;
    }

    await speakTokenList([{ tokens: ['Processing vibe coding request'], category: undefined }]);
    
    // Get original text for diff comparison
    const originalText = editor.document.getText();
    
    try {
        log(`[vibe_coding] Starting vibe coding request: ${instruction}`);
        const result = await processVibeCodingRequest(editor, instruction, context);
        log(`[vibe_coding] Request processed, showing diff preview`);
        await showDiffPreview(originalText, result);
        log(`[vibe_coding] Diff preview completed`);
    } catch (error) {
        log(`[vibe_coding] Error: ${error}`);
        log(`[vibe_coding] Error stack: ${error instanceof Error ? error.stack : 'No stack trace'}`);
        await speakTokenList([{ tokens: ['Error processing vibe coding request'], category: undefined }]);
        vscode.window.showErrorMessage(`Vibe Coding Error: ${error}`);
    }
}

async function getIntelligentContext(editor: vscode.TextEditor): Promise<ContextInfo> {
    const document = editor.document;
    const selection = editor.selection;
    const cursorPosition = editor.selection.active;
    const fullText = document.getText();
    
    // 1. Check for user selection first
    const selectedCode = document.getText(selection);
    if (selectedCode.trim()) {
        log(`[vibe_coding] Using selected code (${selectedCode.length} chars)`);
        return {
            selectedCode,
            focusedFunction: null,
            cursorPosition,
            contextLines: selectedCode.split('\n'),
            isLargeFile: false
        };
    }
    
    // 2. Try to find function under cursor using regex
    const focusedFunction = findFunctionUnderCursor(fullText, cursorPosition.line);
    
    // 3. Use AST analysis to get more context if needed
    const astContext = await getASTContext(document, cursorPosition);
    
    // 4. Determine if this is a large file
    const isLargeFile = fullText.split('\n').length > 500;
    
    let contextLines: string[];
    if (focusedFunction) {
        log(`[vibe_coding] Found function under cursor: ${focusedFunction.substring(0, 100)}...`);
        contextLines = focusedFunction.split('\n');
    } else if (astContext) {
        log(`[vibe_coding] Using AST context`);
        contextLines = astContext.split('\n');
    } else {
        log(`[vibe_coding] Using full file context`);
        contextLines = fullText.split('\n');
    }
    
    return {
        selectedCode: '',
        focusedFunction,
        cursorPosition,
        contextLines,
        isLargeFile
    };
}

function findFunctionUnderCursor(fullText: string, cursorLine: number): string | null {
    const lines = fullText.split('\n');
    
    // Look for function definitions near the cursor
    const functionPatterns = [
        /^def\s+\w+\s*\(/,           // Python functions
        /^async\s+def\s+\w+\s*\(/,    // Python async functions
        /^class\s+\w+/,               // Python classes
        /^function\s+\w+\s*\(/,       // JavaScript functions
        /^const\s+\w+\s*=\s*\(/,      // JavaScript arrow functions
        /^let\s+\w+\s*=\s*\(/,        // JavaScript arrow functions
        /^var\s+\w+\s*=\s*\(/,        // JavaScript arrow functions
        /^public\s+.*\s+\w+\s*\(/,    // Java/C# methods
        /^private\s+.*\s+\w+\s*\(/,   // Java/C# methods
        /^protected\s+.*\s+\w+\s*\(/, // Java/C# methods
    ];
    
    // Search backwards from cursor to find the most recent function
    for (let i = cursorLine; i >= 0; i--) {
        const line = lines[i];
        for (const pattern of functionPatterns) {
            if (pattern.test(line)) {
                // Found a function definition, extract the function
                return extractFunction(lines, i);
            }
        }
    }
    
    return null;
}

function extractFunction(lines: string[], startLine: number): string {
    const functionLines: string[] = [];
    let braceCount = 0;
    let parenCount = 0;
    let inFunction = false;
    
    for (let i = startLine; i < lines.length; i++) {
        const line = lines[i];
        functionLines.push(line);
        
        // Count braces and parentheses to find function end
        for (const char of line) {
            if (char === '{') {
                braceCount++;
            }
            if (char === '}') {
                braceCount--;
            }
            if (char === '(') {
                parenCount++;
            }
            if (char === ')') {
                parenCount--;
            }
        }
        
        // For Python, look for indentation level
        if (lines[startLine].startsWith('def ') || lines[startLine].startsWith('class ')) {
            const baseIndent = lines[startLine].match(/^\s*/)?.[0].length || 0;
            const currentIndent = line.match(/^\s*/)?.[0].length || 0;
            
            // If we're back to the base indentation level and not at the start
            if (i > startLine && currentIndent <= baseIndent && line.trim() !== '') {
                functionLines.pop(); // Remove the last line as it's outside the function
                break;
            }
        } else {
            // For other languages, use brace counting
            if (braceCount === 0 && parenCount === 0 && i > startLine) {
                break;
            }
        }
    }
    
    return functionLines.join('\n');
}

async function getASTContext(document: vscode.TextDocument, cursorPosition: vscode.Position): Promise<string | null> {
    try {
        // Get the symbol at the cursor position
        const symbols = await vscode.commands.executeCommand<vscode.SymbolInformation[]>(
            'vscode.executeDocumentSymbolProvider',
            document.uri
        );
        
        if (!symbols || symbols.length === 0) {
            return null;
        }
        
        // Find the symbol that contains the cursor position
        const cursorOffset = document.offsetAt(cursorPosition);
        let targetSymbol: vscode.SymbolInformation | null = null;
        
        for (const symbol of symbols) {
            const symbolRange = symbol.location.range;
            const symbolStart = document.offsetAt(symbolRange.start);
            const symbolEnd = document.offsetAt(symbolRange.end);
            
            if (cursorOffset >= symbolStart && cursorOffset <= symbolEnd) {
                targetSymbol = symbol;
                break;
            }
        }
        
        if (targetSymbol) {
            // Extract the code for this symbol
            const symbolRange = targetSymbol.location.range;
            const symbolCode = document.getText(symbolRange);
            log(`[vibe_coding] Found AST symbol: ${targetSymbol.name} (${symbolCode.length} chars)`);
            return symbolCode;
        }
        
        return null;
    } catch (error) {
        log(`[vibe_coding] AST analysis failed: ${error}`);
        return null;
    }
}

async function processVibeCodingRequest(
    editor: vscode.TextEditor, 
    instruction: string,
    context: ContextInfo
): Promise<VibeCodingResult> {
    const document = editor.document;
    const originalText = document.getText();
    
    // Use the intelligent context
    const contextText = context.selectedCode || context.focusedFunction || context.contextLines.join('\n');
    
    // Determine the type of request and handle it appropriately
    const requestType = analyzeRequestType(instruction);
    
    let modifiedCode: string;
    
    // Always use smart code modification approach for all requests including tests
    if (requestType === 'modify_function' && context.focusedFunction) {
        // For function modifications, replace the specific function
        modifiedCode = await handleModifyFunctionRequest(originalText, context.focusedFunction, instruction);
    } else if (requestType === 'add_function') {
        // For new functions, add at the end or in appropriate location
        modifiedCode = await handleAddFunctionRequest(originalText, instruction);
    } else {
        // Use smart code modification approach for other requests
        modifiedCode = await generateSmartCodeModification(originalText, instruction, context);
    }
    
    // Calculate differences using smart analysis
    const result = calculateSmartCodeChanges(originalText, modifiedCode);
    
    // Enhance summary with instruction context if needed
    if (result.summary && instruction) {
        const enhancedSummary = await generateChangeSummary(instruction, result.changes, context);
        result.summary = enhancedSummary || result.summary;
    }
    
    return result;
}

function analyzeRequestType(instruction: string): 'add_test' | 'modify_function' | 'add_function' | 'general' {
    const lowerInstruction = instruction.toLowerCase();
    
    if (lowerInstruction.includes('test') || lowerInstruction.includes('unit test') || lowerInstruction.includes('assert')) {
        return 'add_test';
    } else if (lowerInstruction.includes('modify') || lowerInstruction.includes('improve') || lowerInstruction.includes('fix') || lowerInstruction.includes('update')) {
        return 'modify_function';
    } else if (lowerInstruction.includes('add function') || lowerInstruction.includes('create function') || lowerInstruction.includes('new function')) {
        return 'add_function';
    }
    
    return 'general';
}

// Removed handleAddTestRequest - now using smart code modification for all requests

async function handleModifyFunctionRequest(originalText: string, functionCode: string, instruction: string): Promise<string> {
    const prompt = `You are a helpful coding assistant. The user wants to modify this function:

${functionCode}

Modification request: "${instruction}"

Please provide the modified function. Return ONLY the modified function code, no explanations or markdown formatting.`;

    const modifiedFunctionCode = await callLLMForCodeModification(prompt, { cursorPosition: { line: 0, character: 0 } } as ContextInfo);
    const cleanModifiedFunction = stripCodeFences(modifiedFunctionCode);
    
    // Replace the original function with the modified one
    return originalText.replace(functionCode, cleanModifiedFunction);
}

async function handleAddFunctionRequest(originalText: string, instruction: string): Promise<string> {
    const prompt = `You are a helpful coding assistant. The user wants to add a new function to this code:

${originalText}

Request: "${instruction}"

Please generate the new function. Return ONLY the function code, no explanations or markdown formatting.`;

    const newFunctionCode = await callLLMForCodeModification(prompt, { cursorPosition: { line: 0, character: 0 } } as ContextInfo);
    const cleanNewFunction = stripCodeFences(newFunctionCode);
    
    // Add the new function at the end of the file
    return originalText + '\n\n' + cleanNewFunction;
}

function createVibeCodingPrompt(contextCode: string, instruction: string, context: ContextInfo): string {
    let prompt = `You are a helpful coding assistant. The user wants to modify their code based on this instruction: "${instruction}"

`;
    
    if (context.focusedFunction) {
        prompt += `FOCUS: The user is working on this specific function (the cursor is positioned here):
\`\`\`
${context.focusedFunction}
\`\`\`

`;
    } else if (context.selectedCode) {
        prompt += `SELECTED CODE: The user has selected this code to modify:
\`\`\`
${context.selectedCode}
\`\`\`

`;
    }
    
    prompt += `CONTEXT: Here is the relevant code context:
\`\`\`
${contextCode}
\`\`\`

Please provide a unified diff (patch) that implements the requested changes. The diff must start with "---" and "+++" lines. 

IMPORTANT INSTRUCTIONS:
- If the user asks to "add test code", append the test at the end of the file
- If the user asks to "modify" or "improve" a function, modify that specific function
- If the user asks to "add" something, place it in the most appropriate location
- Use the same coding style and conventions as the existing code
- Do not include any explanations, markdown formatting, or code fences
- Only output the unified diff

If the instruction is unclear or impossible to implement, return an empty diff.

Example format:
--- original
+++ modified
@@ -10,6 +10,15 @@
 unchanged line
-removed line
+added line
 unchanged line`;
    
    return prompt;
}

/**
 * Smart code modification that analyzes context and places code appropriately
 */
async function generateSmartCodeModification(originalText: string, instruction: string, context: ContextInfo): Promise<string> {
    try {
        const { callLLMForCompletion } = await import('../llm.js');
        
        // Analyze the instruction to determine the best approach
        const isTestRequest = /ÌÖåÏä§Ìä∏|test.*Ìï®Ïàò|Ìï®Ïàò.*ÌÖåÏä§Ìä∏|write.*test|create.*test|add.*test/i.test(instruction);
        const isFunctionRequest = /Ìï®Ïàò|function/i.test(instruction) && !isTestRequest;
        const isClassRequest = /ÌÅ¥ÎûòÏä§|class/i.test(instruction);
        
        // Enhanced system prompt for complete code generation
        const systemPrompt = `You are an expert coding assistant that generates high-quality, complete code files.

TASK: Analyze the code and instruction, then return a COMPLETE, well-structured file that fulfills the request.

APPROACH:
- You may rewrite the entire file if it improves code quality, structure, or functionality
- Focus on creating clean, maintainable, and well-organized code
- Add proper type hints, error handling, and documentation where appropriate
- Ensure all existing functionality is preserved and enhanced

SMART ORGANIZATION RULES:
1. **Imports**: Place all imports at the top, organized logically
2. **Functions**: Organize functions in logical order (utilities first, main functions, then tests)
3. **Test Functions**: Create comprehensive test classes with proper unittest structure
4. **Code Quality**: Improve variable names, add type hints, enhance error handling
5. **Documentation**: Add docstrings and comments where helpful

CONTEXT ANALYSIS:
- Current cursor: Line ${context.cursorPosition.line + 1}
- In function: ${context.focusedFunction || 'None'}
- Selected code: ${context.selectedCode ? 'Yes' : 'No'}
- Request type: ${isTestRequest ? 'Test Generation' : isFunctionRequest ? 'Function' : isClassRequest ? 'Class' : 'General'}

FOR TEST GENERATION:
- Create comprehensive test classes with multiple test methods
- Test edge cases, error conditions, and normal operation
- Use descriptive test method names
- Add proper assertions and error checking
- Organize tests logically within the test class

IMPORTANT:
- Return COMPLETE, production-ready code
- Preserve all existing functionality while improving code quality
- Make the code more maintainable and robust
- Focus on creating the best possible version of the requested code`;

        let prompt: string;
        
        if (isTestRequest) {
            // Extract function names from original code for targeted testing
            const functionNames = extractFunctionNames(originalText);
            const functionList = functionNames.join(', ');
            
            prompt = `Generate ONLY test code. Do NOT include original functions.

Functions to test: ${functionList}

Return EXACTLY this format:
\`\`\`python
import unittest

class TestFunctions(unittest.TestCase):
    def test_function1(self):
        # Test function1 here
        pass
    
    def test_function2(self):
        # Test function2 here  
        pass
\`\`\`

CRITICAL: Return ONLY the import and test class. No original functions, no main blocks, no explanations.`;
        } else {
            prompt = `Original Code:
\`\`\`
${originalText}
\`\`\`

Instruction: ${instruction}

Please analyze the code structure and place the requested changes in the most appropriate location. Return the complete modified file.`;
        }
        
        log(`[vibe_coding] Smart modification request: ${instruction}`);
        
        const modifiedCode = await callLLMForCompletion(systemPrompt, prompt, 4000, 0.1);
        
        // Clean up the response
        const cleanedCode = stripCodeFences(modifiedCode);
        
        log(`[vibe_coding] Smart modification completed`);
        
        // For test requests, clean and merge the test code
        if (isTestRequest) {
            const cleanTestCode = cleanupGeneratedTestCode(cleanedCode);
            
            // If the cleaned test code is still problematic, generate a template
            if (cleanTestCode.includes('def ') && !cleanTestCode.includes('def test_')) {
                log(`[vibe_coding] LLM generated bad test code, using template fallback`);
                const templateCode = generateTestTemplate(originalText);
                return await smartMergeTestCode(originalText, templateCode);
            }
            
            return await smartMergeTestCode(originalText, cleanTestCode);
        }
        
        return cleanedCode;
    } catch (error) {
        log(`[vibe_coding] Smart modification error: ${error}`);
        // Fallback to original approach
        return await fallbackCodeModification(originalText, instruction, context);
    }
}

/**
 * Extract function names from code
 */
function extractFunctionNames(code: string): string[] {
    const lines = code.split('\n');
    const functionNames: string[] = [];
    
    for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed.startsWith('def ') && !trimmed.startsWith('def test_')) {
            const match = trimmed.match(/def\s+(\w+)\s*\(/);
            if (match && match[1] !== 'main') {
                functionNames.push(match[1]);
            }
        }
    }
    
    return functionNames;
}

/**
 * Generate a basic test template when LLM fails
 */
function generateTestTemplate(originalCode: string): string {
    const functionNames = extractFunctionNames(originalCode);
    
    if (functionNames.length === 0) {
        return `import unittest

class TestFunctions(unittest.TestCase):
    def test_placeholder(self):
        # Add your tests here
        pass`;
    }
    
    let template = `import unittest

class TestFunctions(unittest.TestCase):
`;
    
    for (const funcName of functionNames) {
        template += `    def test_${funcName}(self):
        # Test ${funcName} function
        # TODO: Add actual test cases
        pass
    
`;
    }
    
    return template.trim();
}

/**
 * Clean up generated test code to remove unwanted parts
 */
function cleanupGeneratedTestCode(testCode: string): string {
    const lines = testCode.split('\n');
    const cleanedLines: string[] = [];
    
    let inOriginalFunction = false;
    let skipUntilNextClass = false;
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const trimmed = line.trim();
        
        // Skip empty lines at the beginning
        if (cleanedLines.length === 0 && trimmed === '') {
            continue;
        }
        
        // Detect and skip original function definitions
        if (trimmed.startsWith('def ') && !trimmed.startsWith('def test_')) {
            inOriginalFunction = true;
            skipUntilNextClass = true;
            continue;
        }
        
        // Detect class definitions - this ends any function skipping
        if (trimmed.startsWith('class ')) {
            inOriginalFunction = false;
            skipUntilNextClass = false;
            cleanedLines.push(line);
            continue;
        }
        
        // Skip main blocks
        if (trimmed.startsWith('if __name__')) {
            break; // Stop processing here
        }
        
        // Skip main() function calls and similar
        if (trimmed === 'main()' || trimmed.startsWith('unittest.main()')) {
            continue;
        }
        
        // If we're skipping until next class, continue
        if (skipUntilNextClass && !trimmed.startsWith('class ')) {
            continue;
        }
        
        // If we're in an original function, skip
        if (inOriginalFunction) {
            // Check if we've reached the end of the function (next def or class)
            if (trimmed.startsWith('def ') || trimmed.startsWith('class ')) {
                inOriginalFunction = false;
                if (trimmed.startsWith('class ')) {
                    cleanedLines.push(line);
                }
            }
            continue;
        }
        
        // Keep imports and test code
        if (trimmed.startsWith('import ') || 
            trimmed.startsWith('from ') || 
            trimmed.startsWith('class ') ||
            trimmed.startsWith('def test_') ||
            line.startsWith('    ') || // Indented lines (method bodies)
            trimmed === '') { // Empty lines for spacing
            cleanedLines.push(line);
        }
    }
    
    const result = cleanedLines.join('\n').trim();
    log(`[vibe_coding] Cleaned test code: ${result.substring(0, 200)}...`);
    return result;
}

/**
 * Smart merge test code with original code
 */
async function smartMergeTestCode(originalText: string, testCode: string): Promise<string> {
    try {
        log(`[vibe_coding] Starting smart merge`);
        log(`[vibe_coding] Test code received: ${testCode.substring(0, 200)}...`);
        
        // Since we've cleaned the test code, it should only contain imports and test classes
        const testLines = testCode.split('\n');
        const testImports: string[] = [];
        const testContent: string[] = [];
        
        let foundFirstClass = false;
        
        for (const line of testLines) {
            const trimmed = line.trim();
            
            if (trimmed.startsWith('import ') || trimmed.startsWith('from ')) {
                if (!foundFirstClass) {
                    testImports.push(line);
                } else {
                    // Import found after class, treat as part of content
                    testContent.push(line);
                }
            } else if (trimmed.startsWith('class ')) {
                foundFirstClass = true;
                testContent.push(line);
            } else if (foundFirstClass || trimmed !== '') {
                testContent.push(line);
            }
        }
        
        // Process original code - find where to insert imports and where main block starts
        const originalLines = originalText.split('\n');
        const result: string[] = [];
        let lastImportIndex = -1;
        let mainBlockStart = -1;
        
        for (let i = 0; i < originalLines.length; i++) {
            const line = originalLines[i];
            const trimmed = line.trim();
            
            if (trimmed.startsWith('import ') || trimmed.startsWith('from ')) {
                lastImportIndex = i;
            }
            
            if (trimmed.startsWith('if __name__')) {
                mainBlockStart = i;
                break; // Stop here, we'll handle the main block separately
            }
            
            result.push(line);
        }
        
        // Add new imports after existing imports (or at the top if no imports exist)
        if (testImports.length > 0) {
            const insertIndex = lastImportIndex >= 0 ? lastImportIndex + 1 : 0;
            
            // Check if imports already exist to avoid duplicates
            const existingImports = result.join('\n');
            const newImports = testImports.filter(imp => {
                const importName = imp.trim();
                return !existingImports.includes(importName);
            });
            
            if (newImports.length > 0) {
                result.splice(insertIndex, 0, ...newImports);
                // Add blank line after imports if we inserted at the top
                if (insertIndex === 0 && result[newImports.length].trim() !== '') {
                    result.splice(newImports.length, 0, '');
                }
            }
        }
        
        // Add test content before the main block
        if (testContent.length > 0) {
            // Add spacing before test content
            if (result[result.length - 1].trim() !== '') {
                result.push('');
            }
            result.push(...testContent);
        }
        
        // Add the original main block if it exists
        if (mainBlockStart >= 0) {
            // Add spacing before main block
            if (result[result.length - 1].trim() !== '') {
                result.push('');
            }
            
            // Add the rest of the original file (main block)
            for (let i = mainBlockStart; i < originalLines.length; i++) {
                result.push(originalLines[i]);
            }
        }
        
        const finalResult = result.join('\n');
        log(`[vibe_coding] Smart merge completed successfully`);
        return finalResult;
        
    } catch (error) {
        log(`[vibe_coding] Smart merge failed: ${error}`);
        // Fallback to simple append
        return originalText + '\n\n' + testCode;
    }
}

/**
 * Fallback to original diff-based approach
 */
async function fallbackCodeModification(originalText: string, instruction: string, context: ContextInfo): Promise<string> {
    try {
        const prompt = createVibeCodingPrompt(originalText, instruction, context);
        const diff = await callLLMForCodeModification(prompt, context);
        return applyUnifiedDiff(originalText, diff);
    } catch (error) {
        log(`[vibe_coding] Fallback also failed: ${error}`);
        throw error;
    }
}

async function callLLMForCodeModification(prompt: string, context: ContextInfo): Promise<string> {
    try {
        const { callLLMForCompletion } = await import('../llm.js');
        
        // Enhanced system prompt for better code placement
        const systemPrompt = `You are a helpful coding assistant. When asked to modify code, analyze the context and return the complete modified file content.

IMPORTANT GUIDELINES:
1. If adding a new function/method, place it in an appropriate location (e.g., after similar functions, at the end of the class, etc.)
2. If modifying existing code, preserve the original structure and only change what's necessary
3. For test functions, place them in a logical location (e.g., after the function being tested, in a test section, etc.)
4. Maintain proper indentation and code style
5. Return the COMPLETE file content, not just a diff or snippet

Context Information:
- Current cursor position: Line ${context.cursorPosition.line + 1}
- Selected code: ${context.selectedCode || 'None'}
- Current function: ${context.focusedFunction || 'None'}
- File type: ${context.isLargeFile ? 'Large file' : 'Regular file'}`;
        
        log(`[vibe_coding] Sending prompt to LLM: ${prompt.substring(0, 200)}...`);
        
        const modifiedCode = await callLLMForCompletion(systemPrompt, prompt, 3000, 0.1);
        
        log(`[vibe_coding] Received modified code from LLM: ${modifiedCode.substring(0, 200)}...`);
        
        return modifiedCode;
    } catch (error) {
        log(`[vibe_coding] LLM error: ${error}`);
        throw new Error(`Failed to get code modification from LLM: ${error}`);
    }
}

function stripCodeFences(code: string): string {
    // Remove code fences and language specifiers
    let cleaned = code.replace(/^```[\w]*\s*/i, '').replace(/```\s*$/i, '').trim();
    
    // Also handle cases where there might be multiple code blocks
    cleaned = cleaned.replace(/```[\w]*\s*/gi, '').replace(/```/g, '');
    
    return cleaned;
}

/**
 * Enhanced diff calculation that provides better change analysis
 */
function calculateSmartCodeChanges(originalText: string, modifiedText: string): VibeCodingResult {
    const originalLines = originalText.split('\n');
    const modifiedLines = modifiedText.split('\n');
    
    // Use the existing Diff library for detailed analysis
    const changes: CodeChange[] = [];
    const diff = Diff.diffLines(originalText, modifiedText);
    
    let lineNumber = 1;
    let totalAdded = 0;
    let totalRemoved = 0;
    
    // Analyze each diff chunk
    for (const part of diff) {
        const lines = part.value.split('\n');
        // Remove empty last line if it exists
        if (lines[lines.length - 1] === '') {
            lines.pop();
        }
        
        if (part.added) {
            totalAdded += lines.length;
            for (let i = 0; i < lines.length; i++) {
                changes.push({
                    line: lineNumber + i,
                    original: '',
                    modified: lines[i],
                    type: 'added'
                });
            }
        } else if (part.removed) {
            totalRemoved += lines.length;
            for (let i = 0; i < lines.length; i++) {
                changes.push({
                    line: lineNumber + i,
                    original: lines[i],
                    modified: '',
                    type: 'removed'
                });
            }
        } else {
            // Unchanged lines
            lineNumber += lines.length;
        }
    }
    
    // Generate intelligent summary
    const summary = generateIntelligentSummary(changes, totalAdded, totalRemoved);
    
    return {
        changes,
        summary,
        totalAdded,
        totalRemoved,
        modifiedText
    };
}

/**
 * Generate an intelligent summary of what was changed
 */
function generateIntelligentSummary(changes: CodeChange[], totalAdded: number, totalRemoved: number): string {
    if (changes.length === 0) {
        return 'No changes were made to the code.';
    }
    
    // Analyze the types of changes
    const addedLines = changes.filter(c => c.type === 'added');
    const removedLines = changes.filter(c => c.type === 'removed');
    
    // Look for patterns in added and removed code
    const addedCode = addedLines.map(c => c.modified).join('\n');
    const removedCode = removedLines.map(c => c.original).join('\n');
    
    // Detect what was added
    const hasTestClass = /class.*Test.*unittest\.TestCase/i.test(addedCode);
    const hasTestMethods = /def test_/i.test(addedCode);
    const hasTypeHints = /:\s*(str|int|float|bool|List|Dict|Optional)/i.test(addedCode);
    const hasImports = /^(import|from).*$/m.test(addedCode);
    const hasDocstrings = /""".*"""/s.test(addedCode);
    
    // Detect if this is a major rewrite
    const isCompleteRewrite = totalRemoved > 10 && totalAdded > 10;
    const isTestAddition = hasTestClass && hasTestMethods;
    const isCodeImprovement = hasTypeHints || hasDocstrings;
    
    let summary = '';
    
    if (isCompleteRewrite && isTestAddition) {
        const testCount = (addedCode.match(/def test_/g) || []).length;
        summary = `Complete code rewrite with comprehensive tests (${testCount} test methods)`;
        
        if (hasTypeHints) {
            summary += ', added type hints';
        }
        if (hasImports) {
            summary += ', organized imports';
        }
        if (isCodeImprovement) {
            summary += ', improved code quality';
        }
    } else if (isTestAddition) {
        const testCount = (addedCode.match(/def test_/g) || []).length;
        summary = `Added comprehensive test suite with ${testCount} test methods`;
    } else if (isCompleteRewrite) {
        summary = `Complete code rewrite with improvements`;
        
        if (hasTypeHints) {
            summary += ' (added type hints';
        }
        if (hasImports) {
            summary += hasTypeHints ? ', organized imports' : ' (organized imports';
        }
        if (isCodeImprovement) {
            summary += (hasTypeHints || hasImports) ? ', enhanced code quality)' : ' (enhanced code quality)';
        } else if (hasTypeHints || hasImports) {
            summary += ')';
        }
    } else if (totalAdded > 0 && totalRemoved > 0) {
        summary = `Modified code with ${totalAdded} additions and ${totalRemoved} removals`;
    } else if (totalAdded > 0) {
        summary = `Added ${totalAdded} lines of code`;
    } else if (totalRemoved > 0) {
        summary = `Removed ${totalRemoved} lines of code`;
    } else {
        summary = `Modified ${changes.length} locations in the code`;
    }
    
    return summary;
}

function convertFileDiffToContentDiff(diff: string): string {
    // Remove file path headers (--- a/file.py, +++ b/file.py) and convert to content-based diff
    return diff
        .replace(/^---\s+a\/.*$/m, '--- original')
        .replace(/^\+\+\+\s+b\/.*$/m, '+++ modified');
}

function applyUnifiedDiff(originalText: string, diff: string): string {
    if (!diff.trim()) {
        log(`[vibe_coding] Empty diff received`);
        return originalText;
    }
    
    try {
        const cleanDiff = stripCodeFences(diff);
        log(`[vibe_coding] Cleaned diff: ${cleanDiff.substring(0, 200)}...`);
        
        // Check if the diff starts with the expected format
        if (!cleanDiff.startsWith('---')) {
            log(`[vibe_coding] Diff does not start with "---", format may be incorrect`);
            log(`[vibe_coding] Diff starts with: ${cleanDiff.substring(0, 50)}`);
            return originalText;
        }
        
        // Convert file-based diff to content-based diff
        const contentDiff = convertFileDiffToContentDiff(cleanDiff);
        log(`[vibe_coding] Converted to content diff: ${contentDiff.substring(0, 200)}...`);
        
        const patched = Diff.applyPatch(originalText, contentDiff);
        if (patched === false) {
            log(`[vibe_coding] Patch failed to apply, trying manual fallback`);
            return applyManualChanges(originalText, contentDiff);
        }
        
        log(`[vibe_coding] Patch applied successfully`);
        return patched;
    } catch (e) {
        log(`[vibe_coding] Error applying patch: ${e}`);
        return originalText;
    }
}

function applyManualChanges(originalText: string, diff: string): string {
    try {
        log(`[vibe_coding] Attempting manual change application`);
        
        // Parse the diff manually
        const lines = originalText.split('\n');
        const diffLines = diff.split('\n');
        
        // Find the @@ line to get the line numbers
        const atAtLine = diffLines.find(line => line.startsWith('@@'));
        if (!atAtLine) {
            log(`[vibe_coding] No @@ line found in diff`);
            return originalText;
        }
        
        // Parse @@ -oldStart,oldCount +newStart,newCount @@
        const match = atAtLine.match(/@@ -(\d+),(\d+) \+(\d+),(\d+) @@/);
        if (!match) {
            log(`[vibe_coding] Could not parse @@ line: ${atAtLine}`);
            return originalText;
        }
        
        const oldStart = parseInt(match[1]) - 1; // Convert to 0-based
        const oldCount = parseInt(match[2]);
        const newStart = parseInt(match[3]) - 1; // Convert to 0-based
        const newCount = parseInt(match[4]);
        
        log(`[vibe_coding] Parsed diff: oldStart=${oldStart}, oldCount=${oldCount}, newStart=${newStart}, newCount=${newCount}`);
        
        // Find the context lines in the diff
        const contextLines = [];
        let i = diffLines.indexOf(atAtLine) + 1;
        while (i < diffLines.length && !diffLines[i].startsWith('@@')) {
            if (diffLines[i].startsWith(' ') || diffLines[i].startsWith('+') || diffLines[i].startsWith('-')) {
                contextLines.push(diffLines[i]);
            }
            i++;
        }
        
        log(`[vibe_coding] Found ${contextLines.length} context lines`);
        
        // Apply the changes manually
        const newLines = [...lines];
        
        // Remove the old lines
        newLines.splice(oldStart, oldCount);
        
        // Add the new lines
        const newContent = contextLines
            .filter(line => line.startsWith('+'))
            .map(line => line.substring(1));
        
        newLines.splice(oldStart, 0, ...newContent);
        
        log(`[vibe_coding] Manual change applied successfully`);
        return newLines.join('\n');
        
    } catch (e) {
        log(`[vibe_coding] Manual change failed: ${e}`);
        return originalText;
    }
}

function calculateCodeChanges(
    originalText: string, 
    modifiedText: string, 
    selection: vscode.Selection
): CodeChange[] {
    const originalLines = originalText.split('\n');
    const modifiedLines = modifiedText.split('\n');
    const changes: CodeChange[] = [];
    
    // Use a more sophisticated diff algorithm
    const maxLines = Math.max(originalLines.length, modifiedLines.length);
    let originalIndex = 0;
    let modifiedIndex = 0;
    
    while (originalIndex < originalLines.length || modifiedIndex < modifiedLines.length) {
        const originalLine = originalLines[originalIndex] || '';
        const modifiedLine = modifiedLines[modifiedIndex] || '';
        
        if (originalLine === modifiedLine) {
            // Lines are identical, move both pointers
            originalIndex++;
            modifiedIndex++;
        } else {
            // Check if this is an addition
            if (originalIndex < originalLines.length && 
                modifiedIndex + 1 < modifiedLines.length && 
                originalLines[originalIndex] === modifiedLines[modifiedIndex + 1]) {
                // This is an addition
                changes.push({
                    line: modifiedIndex + 1,
                    original: '',
                    modified: modifiedLine,
                    type: 'added'
                });
                modifiedIndex++;
            } else if (modifiedIndex < modifiedLines.length && 
                       originalIndex + 1 < originalLines.length && 
                       originalLines[originalIndex + 1] === modifiedLines[modifiedIndex]) {
                // This is a deletion
                changes.push({
                    line: originalIndex + 1,
                    original: originalLine,
                    modified: '',
                    type: 'removed'
                });
                originalIndex++;
            } else {
                // This is a modification
                changes.push({
                    line: originalIndex + 1,
                    original: originalLine,
                    modified: modifiedLine,
                    type: 'modified'
                });
                originalIndex++;
                modifiedIndex++;
            }
        }
    }
    
    return changes;
}

async function generateChangeSummary(instruction: string, changes: CodeChange[], context: ContextInfo): Promise<string> {
    const totalAdded = changes.filter(c => c.type === 'added').length;
    const totalRemoved = changes.filter(c => c.type === 'removed').length;
    const totalModified = changes.filter(c => c.type === 'modified').length;
    
    let summary = `Based on your request "${instruction}", I made the following changes:\n\n`;
    
    // Add context information
    if (context.focusedFunction) {
        summary += `üìå Focus: Function under cursor\n`;
    } else if (context.selectedCode) {
        summary += `üìå Focus: Selected code (${context.selectedCode.length} chars)\n`;
    } else {
        summary += `üìå Focus: Entire file${context.isLargeFile ? ' (large file)' : ''}\n`;
    }
    
    summary += '\n';
    
    if (totalAdded > 0) {
        summary += `‚Ä¢ Added ${totalAdded} new line${totalAdded > 1 ? 's' : ''}\n`;
    }
    if (totalRemoved > 0) {
        summary += `‚Ä¢ Removed ${totalRemoved} line${totalRemoved > 1 ? 's' : ''}\n`;
    }
    if (totalModified > 0) {
        summary += `‚Ä¢ Modified ${totalModified} line${totalModified > 1 ? 's' : ''}\n`;
    }
    
    if (changes.length === 0) {
        summary += `‚Ä¢ No changes were made\n`;
    }
    
    summary += `\nLine changes: +${totalAdded}, -${totalRemoved}`;
    
    return summary;
}

/**
 * Show diff preview based on user configuration
 */
async function showDiffPreview(originalText: string, result: VibeCodingResult) {
    const { changes, summary, totalAdded, totalRemoved, modifiedText } = result;
    
    if (changes.length === 0) {
        await speakTokenList([{ tokens: ['No changes were made'], category: undefined }]);
        vscode.window.showInformationMessage('No changes were made to the code.');
        return;
    }
    
    // Get user preference for diff preview mode
    const config = vscode.workspace.getConfiguration('lipcoder');
    const diffMode = config.get('diffPreviewMode', 'native') as string;
    
    log(`[vibe_coding] Using diff preview mode: ${diffMode}`);
    
    switch (diffMode) {
        case 'native':
            await showNativeDiffPreview(originalText, result);
            break;
        case 'inline':
            await showInlineDiffPreview(originalText, result);
            break;
        case 'popup':
        default:
            await displayVibeCodingResultsFallback(result);
            break;
    }
}

/**
 * Show diff using VS Code's native diff viewer
 */
async function showNativeDiffPreview(originalText: string, result: VibeCodingResult) {
    const { summary, totalAdded, totalRemoved, modifiedText } = result;
    
    try {
        log(`[vibe_coding] Creating temporary files for diff`);
        // Create temporary files for diff comparison
        const originalUri = await createTempFile(originalText, 'original');
        const modifiedUri = await createTempFile(modifiedText, 'modified');
        
        log(`[vibe_coding] Temp files created: ${originalUri.fsPath}, ${modifiedUri.fsPath}`);
        
        // Show diff in VS Code's native diff viewer
        const diffTitle = summary.length > 50 ? 
            `Vibe Coding: ${summary.substring(0, 47)}...` : 
            `Vibe Coding: ${summary}`;
            
        log(`[vibe_coding] Executing vscode.diff command with title: ${diffTitle}`);
        await vscode.commands.executeCommand('vscode.diff', 
            originalUri, 
            modifiedUri, 
            diffTitle,
            { preview: true }
        );
        log(`[vibe_coding] vscode.diff command executed successfully`);
        
        // Show action buttons with keyboard shortcuts info
    const action = await vscode.window.showInformationMessage(
            `${summary}\n\nüìä Changes: +${totalAdded} -${totalRemoved} lines\n\nüí° Tip: Use Ctrl+Shift+Y to accept or Ctrl+Shift+N to reject`,
            { modal: true },
            'Accept Changes',
            'Reject Changes'
        );
        
        if (action === 'Accept Changes') {
            await applyCodeChanges(result);
            await speakVibeCodingSuccess(result);
            
            // Close the diff editor
            await vscode.commands.executeCommand('workbench.action.closeActiveEditor');
        } else {
            await speakTokenList([{ tokens: ['Changes rejected'], category: undefined }]);
            
            // Close the diff editor
            await vscode.commands.executeCommand('workbench.action.closeActiveEditor');
        }
        
        // Clean up temporary files
        await cleanupTempFiles([originalUri, modifiedUri]);
        
    } catch (error) {
        log(`[vibe_coding] Error showing native diff preview: ${error}`);
        // Fallback to popup method
        await displayVibeCodingResultsFallback(result);
    }
}

/**
 * Fallback to simple popup if diff preview fails
 */
async function displayVibeCodingResultsFallback(result: VibeCodingResult) {
    const { changes, summary, totalAdded, totalRemoved } = result;
    
    const action = await vscode.window.showInformationMessage(
        `${summary}\n\nChanges: +${totalAdded} -${totalRemoved} lines`,
        'Apply Changes',
        'Cancel'
    );
    
    if (action === 'Apply Changes') {
        await applyCodeChanges(result);
        await speakVibeCodingSuccess(result);
    } else {
        await speakTokenList([{ tokens: ['Changes cancelled'], category: undefined }]);
    }
}

/**
 * Speak a comprehensive success message after vibe coding generation
 */
async function speakVibeCodingSuccess(result: VibeCodingResult) {
    const { summary, totalAdded, totalRemoved, changes } = result;
    
    try {
        // Start with success announcement
        let message = "Code changes applied successfully. ";
        
        // Detect if this was a complete rewrite
        const isCompleteRewrite = totalRemoved > 10 && totalAdded > 10;
        const hasTests = /test.*method|comprehensive.*test/i.test(summary);
        
        if (isCompleteRewrite && hasTests) {
            message += "Complete code rewrite with comprehensive tests added. ";
        } else if (isCompleteRewrite) {
            message += "Complete code rewrite with improvements applied. ";
        } else if (hasTests) {
            message += "Test suite added successfully. ";
        } else if (totalAdded > 0 && totalRemoved > 0) {
            message += `Modified code with ${totalAdded} additions and ${totalRemoved} removals. `;
        } else if (totalAdded > 0) {
            message += `Added ${totalAdded} lines of code. `;
        } else if (totalRemoved > 0) {
            message += `Removed ${totalRemoved} lines of code. `;
        }
        
        // Add key improvements mentioned in summary
        if (/type hint/i.test(summary)) {
            message += "Type hints added. ";
        }
        if (/import/i.test(summary)) {
            message += "Imports organized. ";
        }
        if (/quality/i.test(summary)) {
            message += "Code quality improved. ";
        }
        
        log(`[vibe_coding] Speaking success message: "${message}"`);
        
        // Convert to token chunks for speaking
        const tokens = message.split(/\s+/).filter(t => t.length > 0);
        const chunks: TokenChunk[] = tokens.map(token => ({
            tokens: [token],
            category: 'literal'
        }));
        
        await speakTokenList(chunks);
        
    } catch (error) {
        log(`[vibe_coding] Error speaking success message: ${error}`);
        // Fallback to basic message
        await speakTokenList([{ 
            tokens: [`Code generation completed with ${totalAdded} additions and ${totalRemoved} removals`], 
            category: undefined 
        }]);
    }
}

/**
 * Create a temporary file for diff comparison
 */
async function createTempFile(content: string, suffix: string): Promise<vscode.Uri> {
    const editor = vscode.window.activeTextEditor;
    const fileExtension = editor ? path.extname(editor.document.fileName) : '.txt';
    
    // Create temp file path
    const tempDir = os.tmpdir();
    const fileName = `lipcoder-${suffix}-${Date.now()}${fileExtension}`;
    const tempFilePath = path.join(tempDir, fileName);
    
    // Write content to temp file
    await fs.promises.writeFile(tempFilePath, content, 'utf8');
    
    return vscode.Uri.file(tempFilePath);
}

/**
 * Clean up temporary files
 */
async function cleanupTempFiles(uris: vscode.Uri[]): Promise<void> {
    for (const uri of uris) {
        try {
            await fs.promises.unlink(uri.fsPath);
            log(`[vibe_coding] Cleaned up temp file: ${uri.fsPath}`);
        } catch (error) {
            log(`[vibe_coding] Failed to cleanup temp file ${uri.fsPath}: ${error}`);
        }
    }
}

/**
 * Enhanced diff preview with inline controls
 */
async function showInlineDiffPreview(originalText: string, result: VibeCodingResult): Promise<void> {
    const { modifiedText, summary, totalAdded, totalRemoved } = result;
    
    try {
        // Create a custom diff document
        const diffContent = createInlineDiffContent(originalText, modifiedText, summary);
        
        // Create and show the diff document
        const doc = await vscode.workspace.openTextDocument({
            content: diffContent,
            language: 'diff'
        });
        
        const editor = await vscode.window.showTextDocument(doc, {
            preview: true,
            viewColumn: vscode.ViewColumn.Beside
        });
        
        // Add custom commands for accept/reject
        const disposables: vscode.Disposable[] = [];
        
        // Register temporary commands
        disposables.push(
            vscode.commands.registerCommand('lipcoder.acceptDiff', async () => {
                await applyCodeChanges(result);
                await speakVibeCodingSuccess(result);
                await vscode.commands.executeCommand('workbench.action.closeActiveEditor');
                disposables.forEach(d => d.dispose());
            })
        );
        
        disposables.push(
            vscode.commands.registerCommand('lipcoder.rejectDiff', async () => {
                await speakTokenList([{ tokens: ['Changes rejected'], category: undefined }]);
                await vscode.commands.executeCommand('workbench.action.closeActiveEditor');
                disposables.forEach(d => d.dispose());
            })
        );
        
        // Show action buttons
        const action = await vscode.window.showInformationMessage(
            `${summary}\n\nüìä Changes: +${totalAdded} -${totalRemoved} lines`,
            { modal: false },
            'Accept Changes',
            'Reject Changes'
        );
        
        if (action === 'Accept Changes') {
            await vscode.commands.executeCommand('lipcoder.acceptDiff');
        } else if (action === 'Reject Changes') {
            await vscode.commands.executeCommand('lipcoder.rejectDiff');
        }
        
    } catch (error) {
        log(`[vibe_coding] Error showing inline diff: ${error}`);
        await displayVibeCodingResultsFallback(result);
    }
}

/**
 * Create inline diff content for display
 */
function createInlineDiffContent(originalText: string, modifiedText: string, summary: string): string {
    const diff = Diff.createPatch('file', originalText, modifiedText, 'Original', 'Modified');
    
    const header = `# Vibe Coding Changes
## ${summary}

### Instructions:
- Green lines (+) will be added
- Red lines (-) will be removed
- Use the popup buttons to Accept or Reject changes

---

`;
    
    return header + diff;
}

async function applyCodeChanges(result: VibeCodingResult) {
    const editor = vscode.window.activeTextEditor;
    if (!editor) {
        return;
    }
    
    // Instead of applying individual changes, replace the entire document content
    // This prevents line number inconsistencies that cause the "Illegal value for line" error
    const document = editor.document;
    const originalText = document.getText();
    
    // Get the modified text from the result
    const modifiedText = result.modifiedText;
    
    // Replace the entire document content
    await editor.edit(editBuilder => {
        const fullRange = new vscode.Range(
            document.positionAt(0),
            document.positionAt(originalText.length)
        );
        editBuilder.replace(fullRange, modifiedText);
    });
}

// Register the command
export function registerVibeCodingCommands(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        vscode.commands.registerCommand('lipcoder.vibeCoding', activateVibeCoding)
    );
} 